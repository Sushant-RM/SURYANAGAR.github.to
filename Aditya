<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computational Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        .section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>Computational Concepts</h1>

    <div class="section">
        <h2>1. Problems in Nature (Iteration, Recursion, Backtracking)</h2>
        <ul>
            <li><strong>Iteration:</strong> Ecosystem Cycles, Population Dynamics, Nature Patterns</li>
            <li><strong>Recursion:</strong> Mountains, River Networks, Fibonacci Sequence, Cell Division</li>
            <li><strong>Backtracking:</strong> Used to solve puzzles like Sudoku, Crosswords, Word Searches, Maze Solving, etc.</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. Space and Time Complexity</h2>
        <h3>Space Complexity:</h3>
        <ul>
            <li>Measures the memory required by an algorithm.</li>
            <li><strong>Importance:</strong> Optimize computational resources (memory and time).</li>
        </ul>
        <h3>Time Complexity:</h3>
        <ul>
            <li>Measures how execution time grows with input size.</li>
            <li><strong>Importance:</strong> Ensure scalability for large inputs in real-world applications.</li>
            <li><strong>Orders of Growth:</strong>
                <ul>
                    <li>Constant O(1): Accessing array elements.</li>
                    <li>Logarithmic O(log n): Binary search.</li>
                    <li>Linear O(n): Single-pass algorithms.</li>
                    <li>Quadratic O(n<sup>2</sup>): Nested loops like Bubble Sort.</li>
                    <li>Exponential O(2<sup>n</sup>): Recursive algorithms like the Tower of Hanoi.</li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2>3. Takeaways from Different Design Principles</h2>
        <ul>
            <li><strong>Decomposition:</strong> Breaking down large, complex problems into smaller, manageable sub-problems.</li>
            <li><strong>Pattern Recognition:</strong> Identifying recurring patterns or similarities within a problem.</li>
            <li><strong>Abstraction:</strong> Simplifying complex systems by focusing on essential features.</li>
            <li><strong>Brave and Cautious Travel:</strong> 
                <ul>
                    <li>Brave: Depth First Search (DFS).</li>
                    <li>Cautious: Breadth First Search (BFS).</li>
                </ul>
            </li>
            <li><strong>Pruning:</strong> Eliminating unnecessary paths to improve efficiency (e.g., N-Queens Problem).</li>
            <li><strong>Lazy Propagation/Evaluation:</strong> Optimizes updates in large datasets (e.g., segment trees).</li>
            <li><strong>Sliding Window:</strong> Maintains relevant information for overlapping sub-arrays.</li>
            <li><strong>Level Order Traversal:</strong> Processes tree nodes level by level (BFS in graphs).</li>
            <li><strong>Hierarchical Data:</strong> Organizes data in parent-child relationships.</li>
            <li><strong>Edge Relaxation:</strong> Updates shortest known distance in graph algorithms.</li>
            <li><strong>Balancing and Rotations:</strong> Maintains efficiency in tree-based data structures.</li>
            <li><strong>Kleene Closure:</strong> Computes transitive closure in automata and graphs.</li>
            <li><strong>Pre-Computing:</strong> Stores frequently used results in advance to reduce runtime.</li>
            <li><strong>Parental Dominance:</strong> Ensures root efficiency in heaps.</li>
            <li><strong>Prefix and Suffix:</strong> Aids in pattern matching and string operations.</li>
            <li><strong>Partitioning:</strong> Divides problems into smaller sub-problems.</li>
            <li><strong>Bit Manipulations:</strong> Optimizes memory and computation.</li>
            <li><strong>Memoization:</strong> Stores previously computed results in recursive algorithms.</li>
            <li><strong>Invariants:</strong> Conditions that remain constant during execution.</li>
            <li><strong>Shortest Path Trees:</strong> Illustrates shortest routes in navigation and network optimization.</li>
        </ul>
    </div>

    <div class="section">
        <h2>4. Hierarchical Data and Optimization Using Trees</h2>
        <ul>
            <li><strong>Trees:</strong> Hierarchical data organization. Traversals can be costly in unbalanced trees.</li>
            <li><strong>Binary Search Tree (BST):</strong> Facilitates searching, insertion, deletion with worst-case O(n).</li>
            <li><strong>AVL Trees:</strong> Self-balancing BSTs using rotations to maintain efficiency.</li>
            <li><strong>2-3 Trees:</strong> Ensures balanced height with efficient searching and operations.</li>
            <li><strong>Red-Black Trees:</strong> Uses color rules to maintain approximately balanced height (O(log n)).</li>
            <li><strong>Heap:</strong> Priority queue implementation, useful in graph algorithms like Dijkstra's.</li>
            <li><strong>Trie:</strong> Prefix tree used for string storage (e.g., autocomplete, dictionaries).</li>
        </ul>
    </div>

    <div class="section">
        <h2>5. Need for Array Query Algorithms</h2>
        <ul>
            <li><strong>Applications:</strong>
                <ul>
                    <li>Efficient range queries (sum, max, min).</li>
                    <li>Dynamic updates in arrays.</li>
                    <li>Graph algorithms (e.g., Dijkstra's).</li>
                </ul>
            </li>
            <li><strong>Principles:</strong> 
                <ul>
                    <li>Pre-computation</li>
                    <li>Divide and conquer</li>
                    <li>Sliding window</li>
                    <li>Dynamic programming</li>
                    <li>Lazy propagation</li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2>6. Difference Between Trees and Graphs</h2>
        <h3>Trees:</h3>
        <ul>
            <li>Hierarchical data structure with no cycles.</li>
            <li>Single root node with unique paths between nodes.</li>
            <li>Traversals: Pre-order, In-order, Post-order.</li>
        </ul>
        <h3>Graphs:</h3>
        <ul>
            <li>Collection of vertices connected by edges, can form cycles.</li>
            <li>No root node; multiple paths may exist between nodes.</li>
            <li>Traversals: Depth First Search (DFS), Breadth First Search (BFS).</li>
        </ul>
        <h3>Applications:</h3>
        <ul>
            <li><strong>Trees:</strong> Used in BST, heaps, tries, etc.</li>
            <li><strong>Graphs:</strong> Used in social networks, web graphs, etc.</li>
        </ul>
    </div>
</body>
</html>
